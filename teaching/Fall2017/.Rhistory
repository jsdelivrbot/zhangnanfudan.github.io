f3 <- exp(-x) / (1 - exp(-1))
f4 <- 4 / ((1 + x^2) * pi)
g <- exp(-x) / (1 + x^2)
plot(x, g, type = "l", main = "", ylab = "",
ylim = c(0,2), lwd = w)
lines(x, g/g, lty = 2, lwd = w)
lines(x, f1, lty = 3, lwd = w)
x <- seq(0, 1, .01)
w <- 2
f1 <- exp(-x)
f2 <- (1 / pi) / (1 + x^2)
f3 <- exp(-x) / (1 - exp(-1))
f4 <- 4 / ((1 + x^2) * pi)
g <- exp(-x) / (1 + x^2)
plot(x, g, type = "l", main = "", ylab = "",
ylim = c(0,2), lwd = w)
lines(x, g/g, lty = 2, lwd = w)
lines(x, f1, lty = 3, lwd = w)
lines(x, f2, lty = 4, lwd = w)
lines(x, f3, lty = 5, lwd = w)
lines(x, f4, lty = 6, lwd = w)
legend("topright", legend = c("g", 0:4),
lty = 1:6, lwd = w, inset = 0.02)
plot(x, g, type = "l", main = "", ylab = "",
ylim = c(0,2), lwd = w, col=1)
lines(x, g/g, col = 2, lwd = w)
lines(x, f1, col = 3, lwd = w)
lines(x, f2, col = 4, lwd = w)
lines(x, f3, col = 5, lwd = w)
lines(x, f4, col = 6, lwd = w)
legend("topright", legend = c("g", 0:4),
col = 1:6, lwd = w, inset = 0.02)
plot(x, g, type = "l", main = "", ylab = "",
ylim = c(0,3.2), lwd = w, col = 2)
lines(x, g/f1, col = 3, lwd = w)
lines(x, g/f2, col = 4, lwd = w)
lines(x, g/f3, col = 5, lwd = w)
lines(x, g/f4, col = 6, lwd = w)
legend("topright", legend = c(0:4),
col = 2:6, lwd = w, inset = 0.02)
dev.off()
m <- 10000
theta.hat <- se <- numeric(5)
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1)
}
x <- runif(m)     #using f0
fg <- g(x)
theta.hat[1] <- mean(fg)
se[1] <- sd(fg)
x <- rexp(m, 1)   #using f1
fg <- g(x) / exp(-x)
theta.hat[2] <- mean(fg)
se[2] <- sd(fg)
x <- rcauchy(m)   #using f2
i <- c(which(x > 1), which(x < 0))
x[i] <- 2  #to catch overflow errors in g(x)
fg <- g(x) / dcauchy(x)
theta.hat[3] <- mean(fg)
se[3] <- sd(fg)
u <- runif(m)     #f3, inverse transform method
x <- - log(1 - u * (1 - exp(-1)))
fg <- g(x) / (exp(-x) / (1 - exp(-1)))
theta.hat[4] <- mean(fg)
se[4] <- sd(fg)
u <- runif(m)    #f4, inverse transform method
x <- tan(pi * u / 4)
fg <- g(x) / (4 / ((1 + x^2) * pi))
theta.hat[5] <- mean(fg)
se[5] <- sd(fg)
round(rbind(theta.hat, se),digits=4)
for (i in 1:10) {
estimates[i, 1] <- mean(g(runif(M)))
T2[1] <- mean(g(runif(M/4, 0, .25)))
T2[2] <- mean(g(runif(M/4, .25, .5)))
T2[3] <- mean(g(runif(M/4, .5, .75)))
T2[4] <- mean(g(runif(M/4, .75, 1)))
estimates[i, 2] <- mean(T2)
}
estimates
M <- 20   #number of replicates
T2 <- numeric(4)
estimates <- matrix(0, 10, 2)
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1) }
for (i in 1:10) {
estimates[i, 1] <- mean(g(runif(M)))
T2[1] <- mean(g(runif(M/4, 0, .25)))
T2[2] <- mean(g(runif(M/4, .25, .5)))
T2[3] <- mean(g(runif(M/4, .5, .75)))
T2[4] <- mean(g(runif(M/4, .75, 1)))
estimates[i, 2] <- mean(T2)
}
estimates
apply(estimates, 2, mean)
apply(estimates, 2, var)
rm(list=ls())
library(gss)
install.packages("gss")
library(gss)
x <- seq(0,1,len=101)
trueeta <-  0.3*dnorm(x, mean=0.2,sd=0.008) + 0.7*dnorm(x, mean=0.25,sd=0.005)
y <- 0.3*dnorm(x, mean=0.2,sd=0.008) + 0.7*dnorm(x, mean=0.25,sd=0.005) +rnorm(x)
set.seed(1000)
xknot <- c(5 , 14, 21, 45, 46, 52, 54, 55, 63, 67, 80, 88)
m <- 10000
theta.hat <- se <- numeric(5)
g <- function(x) {
exp(-x - log(1+x^2)) * (x > 0) * (x < 1)
}
x <- runif(m)     #using f0
fg <- g(x)
theta.hat[1] <- mean(fg)
se[1] <- sd(fg)
x <- rexp(m, 1)   #using f1
hist(x)
fg <- g(x) / exp(-x)
set.seed(123)
x <- rexp(m, 1)   #using f1
fg <- g(x) / exp(-x)
theta.hat[2] <- mean(fg)
mean(fg)
set.seed(123)
x <- rexp(m, 1)   #using f1
i <- c(which(x > 1))
x[i] <- 2
fg <- g(x) / exp(-x)
theta.hat[2] <- mean(fg)
mean(fg)
x <- rcauchy(m)   #using f2
set.seed(123)
x <- rcauchy(m)   #using f2
i <- c(which(x > 1), which(x < 0))
x[i] <- 2  #to catch overflow errors in g(x)
fg <- g(x) / dcauchy(x)
mean(fg)
set.seed(123)
x <- rcauchy(m)   #using f2
i <- c(which(x > 1), which(x < 0))
x[i] <- 3  #to catch overflow errors in g(x)
fg <- g(x) / dcauchy(x)
mean(fg)
set.seed(123)
x <- rcauchy(m)   #using f2
fg <- g(x) / dcauchy(x)
mean(fg)
mean(g(x))
hist(x)
range(x)
g(3905.195)
g(-3905.195)
log(3900^2)
exp(-3900)
exp(-3900-log(1+3900^2))
range(x)
exp(1600)
mean(c(1,exp(1600)))
g
g(-1600)
10^12
10^24
10^1000
10^100
2^100
2^1000
2^10000
exp(-1600)
exp(1600)
=======
m <- 100000
g <- numeric(m)
for (i in 1:m) {
x <- rnorm(2)
g[i] <- abs(x[1] - x[2])
}
est <- mean(g)
est
sd(g)/sqrt(m)
sqrt(sum((g - mean(g))^2)/(m*(m-1)))
?sd
sqrt(sum((g - mean(g))^2)/(m*(m-1)))
sqrt(sum((g - mean(g))^2)) / m
sqrt((2-4/pi)/m)
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- sum(x[2:(n-1)]) / (n-2)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #se
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- median(x)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #se
n <- 20
m <- 1000
mse=numeric(10)
for(k in 0:9)
{
tmean <- numeric(m)
for (i in 1:m)
{
x <- sort(rnorm(n))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse[k+1] <- mean(tmean^2)
}
plot(mse)
# Different levels of trimming
n <- 20
m <- 1000
mse=numeric(10)
for(k in 0:9)
{
tmean <- numeric(m)
for (i in 1:m)
{
x <- sort(rnorm(n))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse[k+1] <- mean(tmean^2)
}
plot(mse)
# Different levels of trimming
n <- 20
m <- 1000
mse=numeric(10)
for(k in 0:9)
{
tmean <- numeric(m)
for (i in 1:m)
{
x <- sort(rnorm(n))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse[k+1] <- mean(tmean^2)
}
plot(mse)
# Different levels of trimming
n <- 20
m <- 1000
mse=numeric(10)
for(k in 0:9)
{
tmean <- numeric(m)
for (i in 1:m)
{
x <- sort(rnorm(n))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse[k+1] <- mean(tmean^2)
}
plot(mse)
>>>>>>> origin/master
m <- 100000
g <- numeric(m)
for (i in 1:m) {
x <- rnorm(2)
g[i] <- abs(x[1] - x[2])
}
est <- mean(g)
est
# unbiased
sd(g)/sqrt(m) # sd uses m-1 like var
# unbiased
sqrt(sum((g - mean(g))^2)/(m*(m-1)))
# biased
sqrt(sum((g - mean(g))^2)) / m
# True
sqrt((2-4/pi)/m)
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- sum(x[2:(n-1)]) / (n-2)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #standard error
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- median(x)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #se
# Different levels of trimming
n <- 20
m <- 1000
mse=numeric(10)
for(k in 0:9)
{
tmean <- numeric(m)
for (i in 1:m)
{
x <- sort(rnorm(n))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse[k+1] <- mean(tmean^2)
}
plot(mse)
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 1000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- sum(x[2:(n-1)]) / (n-2)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #standard error
n <- 20000
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- sum(x[2:(n-1)]) / (n-2)
}
mse <- mean(tmean^2)
mse
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 1000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse
n <- 20
alpha <- .05
x <- rnorm(n, mean=0, sd=2)
UCL <- (n-1) * var(x) / qchisq(alpha, df=n-1)
UCL
qchisq(alpha, df=n-1)
alpha
qchisq(.95, df=19)
#set.seed(123)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rnorm(n, mean = 0, sd = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
#count the number of intervals that contain sigma^2=4
sum(UCL > 4)
#or compute the mean to get the confidence level
mean(UCL > 4)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rchisq(n, df = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
sum(UCL > 4)
mean(UCL > 4)
m <- 100000
g <- numeric(m)
for (i in 1:m) {
x <- rnorm(2)
g[i] <- abs(x[1] - x[2])
}
est <- mean(g)
est
2/sqrt(pi)
# unbiased
sd(g)/sqrt(m) # sd uses m-1 like var
# unbiased
sqrt(sum((g - mean(g))^2)/(m*(m-1)))
# biased
sqrt(sum((g - mean(g))^2)) / m
# True
sqrt((2-4/pi)/m)
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- sum(x[2:(n-1)]) / (n-2)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #standard error
n <- 20
m <- 1000
tmean <- numeric(m)
for (i in 1:m) {
x <- sort(rnorm(n))
tmean[i] <- median(x)
}
mse <- mean(tmean^2)
mse
sqrt(sum((tmean - mean(tmean))^2)) / m    #se
# Different levels of trimming
n <- 20
m <- 1000
mse=numeric(10)
for(k in 0:9)
{
tmean <- numeric(m)
for (i in 1:m)
{
x <- sort(rnorm(n))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse[k+1] <- mean(tmean^2)
}
plot(mse)
plot(mse)
set.seed(522)
n <- 20
K <- n/2 - 1
m <- 1000
mse <- matrix(0, n/2, 6)
trimmed.mse <- function(n, m, k, p) {
#MC est of mse for k-level trimmed mean of
#contaminated normal pN(0,1) + (1-p)N(0,100)
tmean <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), size = n,
replace = TRUE, prob = c(p, 1-p))
x <- sort(rnorm(n, 0, sigma))
tmean[i] <- sum(x[(k+1):(n-k)]) / (n-2*k)
}
mse.est <- mean(tmean^2)
se.mse <- sqrt(mean((tmean-mean(tmean))^2)) / sqrt(m)
return(c(mse.est, se.mse))
}
for (k in 0:K) {
mse[k+1, 1:2] <- trimmed.mse(n=n, m=m, k=k, p=1.0)
mse[k+1, 3:4] <- trimmed.mse(n=n, m=m, k=k, p=.95)
mse[k+1, 5:6] <- trimmed.mse(n=n, m=m, k=k, p=.9)
}
mse # see errata
n <- 20
alpha <- .05
x <- rnorm(n, mean=0, sd=2)
UCL <- (n-1) * var(x) / qchisq(alpha, df=n-1)
UCL
#set.seed(123)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rnorm(n, mean = 0, sd = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
#count the number of intervals that contain sigma^2=4
sum(UCL > 4)
#or compute the mean to get the confidence level
mean(UCL > 4)
n <- 20
alpha <- .05
UCL <- replicate(1000, expr = {
x <- rchisq(n, df = 2)
(n-1) * var(x) / qchisq(alpha, df = n-1)
} )
sum(UCL > 4)
mean(UCL > 4)
