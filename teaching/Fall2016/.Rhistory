m <- 5000 #length of chain
xt <- numeric(m)
a <- 1             #parameter of Beta(a,b) proposal dist.
b <- 1             #parameter of Beta(a,b) proposal dist.
p <- .2            #mixing parameter
n <- 30            #sample size
mu <- c(0, 5)      #parameters of the normal densities
sigma <- c(1, 1)
i <- sample(1:2, size=n, replace=TRUE, prob=c(p, 1-p))
x <- rnorm(n, mu[i], sigma[i])
u <- runif(m)
y <- rbeta(m, a, b)      #proposal distribution
xt[1] <- .5
for (i in 2:m) {
fy <- y[i] * dnorm(x, mu[1], sigma[1]) +
(1-y[i]) * dnorm(x, mu[2], sigma[2])
fx <- xt[i-1] * dnorm(x, mu[1], sigma[1]) +
(1-xt[i-1]) * dnorm(x, mu[2], sigma[2])
r <- prod(fy / fx) *
(xt[i-1]^(a-1) * (1-xt[i-1])^(b-1)) /
(y[i]^(a-1) * (1-y[i])^(b-1))
if (u[i] <= r) xt[i] <- y[i] else
xt[i] <- xt[i-1]
}
plot(xt, type="l", ylab="p")
m <- 5000 #length of chain
xt <- numeric(m)
a <- 1             #parameter of Beta(a,b) proposal dist.
b <- 1             #parameter of Beta(a,b) proposal dist.
p <- .2            #mixing parameter
n <- 30            #sample size
mu <- c(0, 5)      #parameters of the normal densities
sigma <- c(1, 1)
i <- sample(1:2, size=n, replace=TRUE, prob=c(p, 1-p))
i
x <- rnorm(n, mu[i], sigma[i])
u <- runif(m)
y <- rbeta(m, a, b)      #proposal distribution
xt[1] <- .5
?prod
sigma[1]
mu[1]
for (i in 2:m) {
fy <- y[i] * dnorm(x, mu[1], sigma[1]) +
(1-y[i]) * dnorm(x, mu[2], sigma[2])
fx <- xt[i-1] * dnorm(x, mu[1], sigma[1]) +
(1-xt[i-1]) * dnorm(x, mu[2], sigma[2])
r <- prod(fy / fx) *
(xt[i-1]^(a-1) * (1-xt[i-1])^(b-1)) /
(y[i]^(a-1) * (1-y[i])^(b-1))
if (u[i] <= r) xt[i] <- y[i] else
xt[i] <- xt[i-1]
}
plot(xt, type="l", ylab="p")
hist(xt[101:m], main="", xlab="p", prob=TRUE)
print(mean(xt[101:m]))
m <- 5000 #length of chain
xt <- numeric(m)
# a <- 1             #parameter of Beta(a,b) proposal dist.
# b <- 1             #parameter of Beta(a,b) proposal dist.
a <- 5             #parameter of Beta(a,b) proposal dist.
b <- 2             #parameter of Beta(a,b) proposal dist.
p <- .2            #mixing parameter
n <- 30            #sample size
mu <- c(0, 5)      #parameters of the normal densities
sigma <- c(1, 1)
# generate the observed sample
i <- sample(1:2, size=n, replace=TRUE, prob=c(p, 1-p))
x <- rnorm(n, mu[i], sigma[i])
# generate the independence sampler chain
u <- runif(m)
y <- rbeta(m, a, b)      #proposal distribution
xt[1] <- .5
for (i in 2:m) {
fy <- y[i] * dnorm(x, mu[1], sigma[1]) +
(1-y[i]) * dnorm(x, mu[2], sigma[2])
fx <- xt[i-1] * dnorm(x, mu[1], sigma[1]) +
(1-xt[i-1]) * dnorm(x, mu[2], sigma[2])
r <- prod(fy / fx) *
(xt[i-1]^(a-1) * (1-xt[i-1])^(b-1)) /
(y[i]^(a-1) * (1-y[i])^(b-1))
if (u[i] <= r) xt[i] <- y[i] else
xt[i] <- xt[i-1]
}
plot(xt, type="l", ylab="p")
hist(xt[101:m], main="", xlab="p", prob=TRUE)
print(mean(xt[101:m]))
m <- 5000 #length of chain
xt <- numeric(m)
# a <- 1             #parameter of Beta(a,b) proposal dist.
# b <- 1             #parameter of Beta(a,b) proposal dist.
a <- 1             #parameter of Beta(a,b) proposal dist.
b <- 4             #parameter of Beta(a,b) proposal dist.
p <- .2            #mixing parameter
n <- 30            #sample size
mu <- c(0, 5)      #parameters of the normal densities
sigma <- c(1, 1)
# generate the observed sample
i <- sample(1:2, size=n, replace=TRUE, prob=c(p, 1-p))
x <- rnorm(n, mu[i], sigma[i])
# generate the independence sampler chain
u <- runif(m)
y <- rbeta(m, a, b)      #proposal distribution
xt[1] <- .5
for (i in 2:m) {
fy <- y[i] * dnorm(x, mu[1], sigma[1]) +
(1-y[i]) * dnorm(x, mu[2], sigma[2])
fx <- xt[i-1] * dnorm(x, mu[1], sigma[1]) +
(1-xt[i-1]) * dnorm(x, mu[2], sigma[2])
r <- prod(fy / fx) *
(xt[i-1]^(a-1) * (1-xt[i-1])^(b-1)) /
(y[i]^(a-1) * (1-y[i])^(b-1))
if (u[i] <= r) xt[i] <- y[i] else
xt[i] <- xt[i-1]
}
plot(xt, type="l", ylab="p")
hist(xt[101:m], main="", xlab="p", prob=TRUE)
print(mean(xt[101:m]))
m <- 50000 #length of chain
xt <- numeric(m)
# a <- 1             #parameter of Beta(a,b) proposal dist.
# b <- 1             #parameter of Beta(a,b) proposal dist.
a <- 5             #parameter of Beta(a,b) proposal dist.
b <- 2             #parameter of Beta(a,b) proposal dist.
p <- .2            #mixing parameter
n <- 30            #sample size
mu <- c(0, 5)      #parameters of the normal densities
sigma <- c(1, 1)
# generate the observed sample
i <- sample(1:2, size=n, replace=TRUE, prob=c(p, 1-p))
x <- rnorm(n, mu[i], sigma[i])
# generate the independence sampler chain
u <- runif(m)
y <- rbeta(m, a, b)      #proposal distribution
xt[1] <- .5
for (i in 2:m) {
fy <- y[i] * dnorm(x, mu[1], sigma[1]) +
(1-y[i]) * dnorm(x, mu[2], sigma[2])
fx <- xt[i-1] * dnorm(x, mu[1], sigma[1]) +
(1-xt[i-1]) * dnorm(x, mu[2], sigma[2])
r <- prod(fy / fx) *
(xt[i-1]^(a-1) * (1-xt[i-1])^(b-1)) /
(y[i]^(a-1) * (1-y[i])^(b-1))
if (u[i] <= r) xt[i] <- y[i] else
xt[i] <- xt[i-1]
}
plot(xt, type="l", ylab="p")
hist(xt[101:m], main="", xlab="p", prob=TRUE)
print(mean(xt[101:m]))
m <- 50000 #length of chain
xt <- numeric(m)
a <- 1             #parameter of Beta(a,b) proposal dist.
b <- 1             #parameter of Beta(a,b) proposal dist.
# a <- 5             #parameter of Beta(a,b) proposal dist.
# b <- 2             #parameter of Beta(a,b) proposal dist.
p <- .2            #mixing parameter
n <- 30            #sample size
mu <- c(0, 5)      #parameters of the normal densities
sigma <- c(1, 1)
# generate the observed sample
i <- sample(1:2, size=n, replace=TRUE, prob=c(p, 1-p))
x <- rnorm(n, mu[i], sigma[i])
# generate the independence sampler chain
u <- runif(m)
y <- rbeta(m, a, b)      #proposal distribution
xt[1] <- .5
for (i in 2:m) {
fy <- y[i] * dnorm(x, mu[1], sigma[1]) +
(1-y[i]) * dnorm(x, mu[2], sigma[2])
fx <- xt[i-1] * dnorm(x, mu[1], sigma[1]) +
(1-xt[i-1]) * dnorm(x, mu[2], sigma[2])
r <- prod(fy / fx) *
(xt[i-1]^(a-1) * (1-xt[i-1])^(b-1)) /
(y[i]^(a-1) * (1-y[i])^(b-1))
if (u[i] <= r) xt[i] <- y[i] else
xt[i] <- xt[i-1]
}
plot(xt, type="l", ylab="p")
hist(xt[101:m], main="", xlab="p", prob=TRUE)
print(mean(xt[101:m]))
library(boot)     #for coal data
data(coal)
coal
dim(coal)
year <- floor(coal)
head(coal)
head(year)
?coal
y <- table(year)
y
plot(y)  #a time plot
y <- tabulate(year)
coal[[1]]
class(coal[[1]])
class(coal[1])
class(coal)
class(coal[[2]])
coal[[1]]
length(coal[[1]])
m(coal[[1]])
dim(coal[[1]])
class(coal[[1]])
coal
data(coal)
year <- floor(coal)
?tabulate
tabulate(year)
class(year)
head(year)
nan=tabulate(as.numeric(year))
year[,1:10]
year[1:10,]
class(year[1:10,])
nan=tabulate(year[,])
nan
plot(nan)
y <- floor(coal[[1]])
y <- tabulate(y)
plot(y)
y <- floor(coal[[1]])  # convert data.frame to numeric
y <- tabulate(y)
y <- y[1851:length(y)]
y <- floor(coal[[1]])  # convert data.frame to numeric
y <- tabulate(y)
head(y)
dim(y)
length(y)
y
sum(y)
tabulate(c(2,3,5))
max(coal)
min(coal)
n <- length(y)    #length of the data
m <- 1000         #length of the chain
mu <- lambda <- k <- numeric(m)
L <- numeric(n)
n
y <- y[1851:length(y)]   # starting from year 1851
n <- length(y)    #length of the data
m <- 1000         #length of the chain
mu <- lambda <- k <- numeric(m)
n
k[1] <- sample(1:n, 1)
L <- numeric(n)
k[1] <- sample(1:n, 1)
n <- length(y)    #length of the data
m <- 1000         #length of the chain
mu <- lambda <- k <- numeric(m)
L <- numeric(n)
k[1] <- sample(1:n, 1)
mu[1] <- 1
lambda[1] <- 1
b1 <- 1
b2 <- 1
for (i in 2:m) {
kt <- k[i-1]
#generate mu
r <- .5 + sum(y[1:kt])
mu[i] <- rgamma(1, shape = r, rate = kt + b1)
#generate lambda
if (kt + 1 > n) r <- .5 + sum(y) else
r <- .5 + sum(y[(kt+1):n])
lambda[i] <- rgamma(1, shape = r, rate = n - kt + b2)
#generate b1 and b2
b1 <- rgamma(1, shape = .5, rate = mu[i]+1)
b2 <- rgamma(1, shape = .5, rate = lambda[i]+1)
for (j in 1:n) {
L[j] <- exp((lambda[i] - mu[i]) * j) *
(mu[i] / lambda[i])^sum(y[1:j])
}
L <- L / sum(L)
#generate k from discrete distribution L on 1:n
k[i] <- sample(1:n, prob=L, size=1)
}
b <- 201
j <- k[b:m]
print(mean(k[b:m]))
print(mean(lambda[b:m]))
print(mean(mu[b:m]))
plot(b1)
plot(k)
plot(mu)
plot(mu,type='l')
plot(lambda,type='l')
plot(mu,type='l')
print(mean(mu[b:m]))
print(mean(lambda[b:m]))
par(mfcol=c(3,1), ask=TRUE)
plot(mu, type="l", ylab="mu")
plot(k, type="l", ylab="change point = k")
par(mfcol=c(3,1), ask=TRUE)
plot(mu, type="l", ylab="mu")
plot(k, type="l", ylab="change point = k")
par(mfcol=c(3,1))
plot(mu, type="l", ylab="mu")
plot(k, type="l", ylab="change point = k")
dev.off()
par(mfcol=c(3,1))
plot(mu, type="l", ylab="mu")
plot(lambda, type="l", ylab="lambda")
plot(k, type="l", ylab="change point = k")
par(mfrow=c(2,3))
labelk <- "changepoint"
label1 <- paste("mu", round(mean(mu[b:m]), 1))
label2 <- paste("lambda", round(mean(lambda[b:m]), 1))
hist(mu[b:m], main="", xlab=label1,
breaks = "scott", prob=TRUE) #mu posterior
hist(lambda[b:m], main="", xlab=label2,
breaks = "scott", prob=TRUE) #lambda posterior
hist(j, breaks=min(j):max(j), prob=TRUE, main="",
xlab = labelk)
par(mfcol=c(1,1), ask=FALSE)  #restore display
par(mfrow=c(1,3))
labelk <- "changepoint"
label1 <- paste("mu", round(mean(mu[b:m]), 1))
label2 <- paste("lambda", round(mean(lambda[b:m]), 1))
hist(mu[b:m], main="", xlab=label1,
breaks = "scott", prob=TRUE) #mu posterior
hist(lambda[b:m], main="", xlab=label2,
breaks = "scott", prob=TRUE) #lambda posterior
hist(j, breaks=min(j):max(j), prob=TRUE, main="",
xlab = labelk)
dev.off()
par(mfrow=c(1,3))
labelk <- "changepoint"
label1 <- paste("mu", round(mean(mu[b:m]), 1))
label2 <- paste("lambda", round(mean(lambda[b:m]), 1))
hist(mu[b:m], main="", xlab=label1,
breaks = "scott", prob=TRUE) #mu posterior
hist(lambda[b:m], main="", xlab=label2,
breaks = "scott", prob=TRUE) #lambda posterior
hist(j, breaks=min(j):max(j), prob=TRUE, main="",
xlab = labelk)
